package main

import (
	"fmt"
	"go/ast"
	"go/importer"
	"go/parser"
	"go/token"
	"go/types"
	"io/ioutil"
	"log"
	"os"
	"path/filepath"
	"strings"
)

func main() {
	if len(os.Args) != 3 || os.Args[1] != "-f" {
		fmt.Printf("Usage: go run main.go -f file.go\n")
		return
	}
	filename := os.Args[2]
	fd, err := os.Open(filename)

	check(err)

	src, err := ioutil.ReadAll(fd)
	check(err)

	fset := token.NewFileSet()
	f, err := parser.ParseFile(fset, filepath.Base(filename), src, parser.ParseComments)
	if err != nil {
		log.Fatal("parse failed:", err)
	}

	// info := types.Info{
	// 	Types: make(map[ast.Expr]types.TypeAndValue),
	// 	Defs:  make(map[*ast.Ident]types.Object),
	// 	Uses:  make(map[*ast.Ident]types.Object),
	// }
	conf := types.Config{Importer: importer.Default()}

	pkg, err := conf.Check("fib", fset, []*ast.File{f}, nil)
	check(err)

	// fmt.Printf("Types: %#v\n", info)

	// Print the method sets of Celsius and *Celsius.
	scope := pkg.Scope()
	names := scope.Names()

	groups := map[string][]string{}

L:
	for i := 0; i < len(names); i++ {
		lu := scope.Lookup(names[i])
		typ := lu.Type()
		if !types.IsInterface(typ) {
			continue
		}

		mset := types.NewMethodSet(typ)
		if mset.Len() != 1 {
			continue
		}

		for i := 0; i < mset.Len(); i++ {
			m := mset.At(i)
			if m.Obj().Name() != "GroupTypes" {
				continue L
			}
			sig, ok := m.Type().(*types.Signature)
			if !ok {
				continue L
			}

			if sig.Results() != nil {
				continue L
			}

			if sig.Params() == nil || sig.Params().Len() == 0 {
				continue L
			}

			// groups can have only 1 type

			params := sig.Params()

			var groupTypes []string
			for j := 0; j < params.Len(); j++ {
				named, ok := params.At(j).Type().(*types.Named)
				if !ok {
					// at least one of the types have no name
					continue L
				}

				groupTypes = append(groupTypes, named.Obj().Name())
			}
			groups[lu.Name()] = groupTypes
		}
	}

	var fout *os.File
	{
		ext := filepath.Ext(filename)
		base := strings.TrimSuffix(filepath.Base(filename), ext) + "_group_interface.go"

		fout, err = os.Create(filepath.Join(filepath.Dir(filename), base))
		check(err)
		defer fout.Close()
	}

	fmt.Fprintf(fout, "// DO NOT EDIT\n")
	fmt.Fprintf(fout, "// Generated by group-interface\n")
	fmt.Fprintf(fout, "\n")
	fmt.Fprintf(fout, "package %s\n", pkg.Name())
	fmt.Fprintf(fout, "\n")
	for groupName, typeNames := range groups {
		args := strings.Join(typeNames, ", ")
		fmt.Fprintf(fout, "// %s group\n", groupName)
		for _, typeName := range typeNames {
			fmt.Fprintf(fout, "func (%s) GroupTypes(%s) {}\n", typeName, args)
		}
	}
}

func check(err error) {
	if err != nil {
		panic(err)
	}
}
